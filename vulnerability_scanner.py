import requests
from bs4 import BeautifulSoup
import re
from urllib.parse import urljoin, urlparse
import json
import time
from typing import List, Dict, Any
import concurrent.futures
import pyautogui
import cv2
import numpy as np
from datetime import datetime
import os
import threading
import keyboard
import subprocess
import platform
import webbrowser
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import nmap
import httpx
import pywinauto
from pywinauto.application import Application
import win32gui
import win32con
import win32api

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        self.hf_api_key = "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"
        self.top_mncs = {
            'google': ['google.com', 'youtube.com', 'gmail.com'],
            'microsoft': ['microsoft.com', 'office.com', 'azure.com'],
            'amazon': ['amazon.com', 'aws.amazon.com'],
            'apple': ['apple.com', 'icloud.com'],
            'meta': ['facebook.com', 'instagram.com', 'whatsapp.com']
        }
        self.recording = False
        self.recording_thread = None
        self.screen_recorder = None
        self.auto_record = True
        self.current_recording = None
        self.vulnerability_detected = False
        self.burp_running = False
        self.tools = {
            'nmap': self._check_nmap_installation,
            'httpx': self._check_httpx_installation
        }
        self.browser = None
        self.burp_app = None

    def _check_tool_installation(self, tool_name: str) -> bool:
        """Check if a security tool is installed"""
        try:
            if platform.system() == 'Windows':
                subprocess.run(['where', tool_name], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            else:
                subprocess.run(['which', tool_name], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return True
        except subprocess.CalledProcessError:
            return False

    def _check_nmap_installation(self) -> bool:
        """Check if Nmap is installed"""
        return self._check_tool_installation('nmap')

    def _check_httpx_installation(self) -> bool:
        """Check if httpx is installed"""
        try:
            import httpx
            return True
        except ImportError:
            return False

    def _start_burp_suite(self):
        """Start Burp Suite for manual testing"""
        try:
            if platform.system() == 'Windows':
                subprocess.Popen(['burpsuite'])
            else:
                subprocess.Popen(['burpsuite'])
            self.burp_running = True
            print("Burp Suite started successfully")
            return True
        except Exception as e:
            print(f"Error starting Burp Suite: {str(e)}")
            return False

    def _setup_proxy(self, proxy_host: str = '127.0.0.1', proxy_port: int = 8080):
        """Setup proxy for Burp Suite"""
        self.session.proxies = {
            'http': f'http://{proxy_host}:{proxy_port}',
            'https': f'http://{proxy_host}:{proxy_port}'
        }
        print(f"Proxy set to {proxy_host}:{proxy_port}")

    def _perform_manual_testing(self, url: str):
        """Perform manual testing with Burp Suite"""
        if not self._start_burp_suite():
            return

        print("\nManual Testing Mode Activated")
        print("1. Start Burp Suite")
        print("2. Configure your browser to use Burp Suite proxy")
        print("3. Browse the target website")
        print("4. Intercept and modify requests")
        print("5. Analyze responses for vulnerabilities")
        print("6. Use Burp Suite tools (Scanner, Intruder, Repeater)")
        print("7. Document findings")

        # Start recording
        self._start_continuous_recording(url)

        # Wait for user to complete manual testing
        input("Press Enter when you're done with manual testing...")

        # Stop recording
        self._stop_continuous_recording()

    def scan(self, target_url: str) -> Dict[str, Any]:
        """Main scanning function that orchestrates all security checks"""
        results = {
            'url': target_url,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'vulnerabilities': [],
            'zero_day_findings': [],
            'recordings': [],
            'manual_testing': []
        }

        try:
            # Check and install required tools
            for tool_name, check_func in self.tools.items():
                if not check_func():
                    print(f"{tool_name} not found. Installing...")
                    self._install_tool(tool_name)

            # Initialize screen recorder
            self.screen_recorder = ScreenRecorder()

            # Validate URL
            if not self._validate_url(target_url):
                results['vulnerabilities'].append({
                    'type': 'Invalid URL',
                    'severity': 'Critical',
                    'description': 'The provided URL is invalid',
                    'recommendation': 'Please provide a valid URL starting with http:// or https://'
                })
                return results

            # Start continuous recording
            self._start_continuous_recording(target_url)

            # Perform automated scanning
            print("\nStarting Automated Scanning...")
            vulnerabilities = self._perform_automated_scan(target_url)
            results['vulnerabilities'].extend(vulnerabilities)

            # Perform manual testing with Burp Suite
            print("\nStarting Manual Testing with Burp Suite...")
            self._perform_manual_testing(target_url)

            # Perform zero-day detection
            print("\nStarting Zero-Day Detection...")
            zero_day_results = self._check_zero_day_vulnerabilities(target_url)
            results['zero_day_findings'].extend(zero_day_results)

            # Stop recording
            self._stop_continuous_recording()

            # Add final recording to results
            if self.current_recording:
                results['recordings'].append(self.current_recording)

        except Exception as e:
            results['vulnerabilities'].append({
                'type': 'Scan Error',
                'severity': 'Critical',
                'description': f'An error occurred during scanning: {str(e)}',
                'recommendation': 'Please try again or contact support'
            })
            self._stop_continuous_recording()

        return results

    def _perform_automated_scan(self, url: str) -> List[Dict[str, str]]:
        """Perform automated scanning using various tools"""
        vulnerabilities = []

        # Nmap scan
        print("Running Nmap scan...")
        nmap_results = self._run_nmap_scan(url)
        vulnerabilities.extend(nmap_results)

        # SQL injection scan
        print("Running SQL injection scan...")
        sql_results = self._run_sqlmap_scan(url)
        vulnerabilities.extend(sql_results)

        # Directory brute force
        print("Running directory brute force...")
        dir_results = self._run_dirb_scan(url)
        vulnerabilities.extend(dir_results)

        # Subdomain enumeration
        print("Running subdomain enumeration...")
        subdomain_results = self._run_subdomain_scan(url)
        vulnerabilities.extend(subdomain_results)

        # Content analysis with Hugging Face
        print("Running AI-based content analysis...")
        ai_results = self._analyze_with_huggingface(url)
        vulnerabilities.extend(ai_results)

        return vulnerabilities

    def _run_nmap_scan(self, url: str) -> List[Dict[str, str]]:
        """Run Nmap scan"""
        vulnerabilities = []
        try:
            nm = nmap.PortScanner()
            host = urlparse(url).netloc
            nm.scan(host, arguments='-sV -sC -p-')
            
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        if service['state'] == 'open':
                            vulnerabilities.append({
                                'type': 'Open Port',
                                'severity': 'Medium',
                                'description': f'Open port {port} running {service["name"]} {service["version"]}',
                                'recommendation': 'Review and secure open ports'
                            })
        except Exception as e:
            print(f"Error running Nmap scan: {str(e)}")
        return vulnerabilities

    def _run_sqlmap_scan(self, url: str) -> List[Dict[str, str]]:
        """Run SQLmap scan"""
        vulnerabilities = []
        try:
            # Basic SQL injection test
            test_url = f"{url}?id=1'"
            response = self.session.get(test_url)
            if "SQL syntax" in response.text or "mysql" in response.text.lower():
                vulnerabilities.append({
                    'type': 'SQL Injection',
                    'severity': 'Critical',
                    'description': 'Potential SQL injection vulnerability detected',
                    'recommendation': 'Implement proper input validation and use prepared statements'
                })
        except Exception as e:
            print(f"Error running SQLmap scan: {str(e)}")
        return vulnerabilities

    def _run_dirb_scan(self, url: str) -> List[Dict[str, str]]:
        """Run directory brute force scan"""
        vulnerabilities = []
        try:
            common_dirs = ['admin', 'backup', 'config', 'database', 'logs']
            for dir in common_dirs:
                test_url = urljoin(url, dir)
                response = self.session.get(test_url)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'type': 'Exposed Directory',
                        'severity': 'Medium',
                        'description': f'Exposed directory found: {dir}',
                        'recommendation': 'Restrict access to sensitive directories'
                    })
        except Exception as e:
            print(f"Error running directory scan: {str(e)}")
        return vulnerabilities

    def _run_subdomain_scan(self, url: str) -> List[Dict[str, str]]:
        """Run subdomain enumeration"""
        vulnerabilities = []
        try:
            domain = urlparse(url).netloc
            # Basic subdomain check
            subdomains = ['dev', 'staging', 'test', 'admin']
            for sub in subdomains:
                test_url = f"https://{sub}.{domain}"
                try:
                    response = self.session.get(test_url, timeout=5)
                    if response.status_code == 200:
                        vulnerabilities.append({
                            'type': 'Exposed Subdomain',
                            'severity': 'Medium',
                            'description': f'Exposed subdomain found: {sub}.{domain}',
                            'recommendation': 'Review and secure all subdomains'
                        })
                except:
                    continue
        except Exception as e:
            print(f"Error running subdomain scan: {str(e)}")
        return vulnerabilities

    def _validate_url(self, url: str) -> bool:
        """Validate the provided URL"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except:
            return False

    def _fetch_content(self, url: str) -> str:
        """Fetch website content with error handling"""
        try:
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            return response.text
        except:
            return ""

    def _check_security_headers(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for missing security headers"""
        vulnerabilities = []
        try:
            headers = response.headers

            security_headers = {
                'X-Frame-Options': {
                    'severity': 'Medium',
                    'description': 'Missing X-Frame-Options header - Clickjacking possible',
                    'recommendation': 'Set X-Frame-Options to DENY or SAMEORIGIN'
                },
                'X-Content-Type-Options': {
                    'severity': 'Medium',
                    'description': 'Missing X-Content-Type-Options header - MIME-sniffing possible',
                    'recommendation': 'Set X-Content-Type-Options to nosniff'
                },
                'Strict-Transport-Security': {
                    'severity': 'High',
                    'description': 'Missing HSTS header - SSL/TLS downgrade possible',
                    'recommendation': 'Implement HSTS with appropriate max-age'
                },
                'Content-Security-Policy': {
                    'severity': 'High',
                    'description': 'Missing CSP header - XSS and injection risks',
                    'recommendation': 'Implement strict CSP rules'
                }
            }

            for header, config in security_headers.items():
                if not headers.get(header):
                    vulnerabilities.append({
                        'type': 'Security Headers',
                        'severity': config['severity'],
                        'description': config['description'],
                        'recommendation': config['recommendation']
                    })

        except Exception as e:
            print(f"Error checking security headers: {str(e)}")

        return vulnerabilities

    def _check_forms(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check form security"""
        vulnerabilities = []
        try:
            soup = BeautifulSoup(content, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:
                # Check for CSRF protection
                if not form.find('input', {'name': ['csrf', 'csrf_token', '_token']}):
                    vulnerabilities.append({
                        'type': 'Form Security',
                        'severity': 'High',
                        'description': 'Form missing CSRF protection',
                        'recommendation': 'Implement CSRF tokens for all forms'
                    })

                # Check password fields
                password_fields = form.find_all('input', {'type': 'password'})
                for field in password_fields:
                    if not field.get('autocomplete', '').lower() == 'off':
                        vulnerabilities.append({
                            'type': 'Form Security',
                            'severity': 'Medium',
                            'description': 'Password field with autocomplete enabled',
                            'recommendation': 'Set autocomplete="off" for password fields'
                        })

        except Exception as e:
            print(f"Error checking forms: {str(e)}")

        return vulnerabilities

    def _check_links(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for dangerous links"""
        vulnerabilities = []
        try:
            soup = BeautifulSoup(content, 'html.parser')
            links = soup.find_all('a')

            for link in links:
                href = link.get('href', '')
                if href.startswith('javascript:'):
                    vulnerabilities.append({
                        'type': 'Link Security',
                        'severity': 'Medium',
                        'description': f'Dangerous javascript: link found: {href}',
                        'recommendation': 'Avoid using javascript: links'
                    })

        except Exception as e:
            print(f"Error checking links: {str(e)}")

        return vulnerabilities

    def _check_scripts(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for dangerous JavaScript patterns"""
        vulnerabilities = []
        try:
            dangerous_patterns = [
                ('eval(', 'Use of eval() function'),
                ('document.write', 'Use of document.write()'),
                ('innerHTML', 'Direct HTML injection'),
                ('setTimeout', 'Potential XSS via setTimeout'),
                ('setInterval', 'Potential XSS via setInterval')
            ]

            for pattern, description in dangerous_patterns:
                if pattern in content:
                    vulnerabilities.append({
                        'type': 'JavaScript Security',
                        'severity': 'Medium',
                        'description': f'Potential security issue: {description}',
                        'recommendation': 'Use safer alternatives to dangerous JavaScript functions'
                    })

        except Exception as e:
            print(f"Error checking scripts: {str(e)}")

        return vulnerabilities

    def _check_meta_tags(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check meta tags for security issues"""
        vulnerabilities = []
        try:
            soup = BeautifulSoup(content, 'html.parser')
            meta_tags = soup.find_all('meta')

            for tag in meta_tags:
                if tag.get('http-equiv', '').lower() == 'refresh':
                    vulnerabilities.append({
                        'type': 'Meta Tag Security',
                        'severity': 'Low',
                        'description': 'Meta refresh tag found',
                        'recommendation': 'Avoid using meta refresh tags'
                    })

        except Exception as e:
            print(f"Error checking meta tags: {str(e)}")

        return vulnerabilities

    def _check_sql_injection(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for SQL injection vulnerabilities"""
        vulnerabilities = []
        try:
            sql_payloads = [
                "' OR '1'='1",
                "1; DROP TABLE users--",
                "' UNION SELECT NULL,NULL,NULL--"
            ]

            for payload in sql_payloads:
                test_url = f"{url}?id={payload}"
                response = self.session.get(test_url)
                if any(indicator in response.text.lower() for indicator in ['sql', 'mysql', 'oracle', 'syntax error']):
                    vulnerabilities.append({
                        'type': 'SQL Injection',
                        'severity': 'Critical',
                        'description': 'Potential SQL injection vulnerability detected',
                        'recommendation': 'Use parameterized queries and input validation'
                    })

        except Exception as e:
            print(f"Error checking SQL injection: {str(e)}")

        return vulnerabilities

    def _check_xss(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for XSS vulnerabilities"""
        vulnerabilities = []
        try:
            xss_payloads = [
                '<script>alert(1)</script>',
                '"><script>alert(1)</script>',
                '><script>alert(1)</script>',
                '<img src=x onerror=alert(1)>'
            ]

            for payload in xss_payloads:
                test_url = f"{url}?q={payload}"
                response = self.session.get(test_url)
                if payload in response.text:
                    vulnerabilities.append({
                        'type': 'XSS',
                        'severity': 'High',
                        'description': 'Potential XSS vulnerability detected',
                        'recommendation': 'Implement proper input validation and output encoding'
                    })

        except Exception as e:
            print(f"Error checking XSS: {str(e)}")

        return vulnerabilities

    def _check_sensitive_files(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for exposed sensitive files"""
        vulnerabilities = []
        try:
            sensitive_files = [
                '/.git/config',
                '/.env',
                '/wp-config.php',
                '/config.php',
                '/debug.log',
                '/.htaccess'
            ]

            for file in sensitive_files:
                test_url = urljoin(url, file)
                response = self.session.get(test_url)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'type': 'Sensitive File Exposure',
                        'severity': 'High',
                        'description': f'Sensitive file exposed: {file}',
                        'recommendation': 'Remove or protect access to sensitive files'
                    })

        except Exception as e:
            print(f"Error checking sensitive files: {str(e)}")

        return vulnerabilities

    def _check_zero_day_vulnerabilities(self, url: str, content: str) -> List[Dict[str, str]]:
        """Check for zero-day vulnerabilities in top MNCs"""
        zero_day_findings = []
        try:
            # Check for unusual error patterns
            error_patterns = [
                'Internal Server Error',
                'Debug Information',
                'Stack Trace',
                'Memory Dump',
                'Core Dump'
            ]
            
            for pattern in error_patterns:
                if pattern.lower() in content.lower():
                    zero_day_findings.append({
                        'type': 'Zero-Day',
                        'severity': 'Critical',
                        'description': f'Potential zero-day vulnerability: {pattern} exposure',
                        'recommendation': 'Disable debug information in production'
                    })

            # Check for unusual response headers
            unusual_headers = [
                'X-Debug',
                'X-Runtime',
                'X-Application-Context',
                'X-Environment'
            ]
            
            response = self.session.get(url)
            for header in unusual_headers:
                if header in response.headers:
                    zero_day_findings.append({
                        'type': 'Zero-Day',
                        'severity': 'Critical',
                        'description': f'Potential zero-day vulnerability: {header} header exposed',
                        'recommendation': 'Remove debug headers in production'
                    })

            # Check for exposed internal paths
            internal_paths = [
                '/internal/',
                '/admin/',
                '/debug/',
                '/test/',
                '/dev/',
                '/staging/'
            ]
            
            for path in internal_paths:
                test_url = urljoin(url, path)
                response = self.session.get(test_url)
                if response.status_code == 200:
                    zero_day_findings.append({
                        'type': 'Zero-Day',
                        'severity': 'Critical',
                        'description': f'Internal path exposed: {path}',
                        'recommendation': 'Restrict access to internal paths'
                    })

            # Check for exposed API endpoints
            api_patterns = [
                '/api/v1/',
                '/api/v2/',
                '/graphql',
                '/swagger',
                '/openapi'
            ]
            
            for pattern in api_patterns:
                test_url = urljoin(url, pattern)
                response = self.session.get(test_url)
                if response.status_code == 200:
                    zero_day_findings.append({
                        'type': 'Zero-Day',
                        'severity': 'Critical',
                        'description': f'API endpoint exposed: {pattern}',
                        'recommendation': 'Implement proper API authentication and documentation'
                    })

        except Exception as e:
            print(f"Error checking zero-day vulnerabilities: {str(e)}")

        return zero_day_findings

    def _analyze_with_huggingface(self, content: str, is_top_mnc: bool) -> List[Dict[str, str]]:
        """Enhanced content analysis using Hugging Face API"""
        vulnerabilities = []
        try:
            headers = {
                'Authorization': f'Bearer {self.hf_api_key}',
                'Content-Type': 'application/json'
            }
            
            # Prepare data for analysis
            data = {
                'inputs': content[:1000],  # Limit content length
                'parameters': {
                    'max_length': 150,
                    'min_length': 30,
                    'top_k': 5,
                    'top_p': 0.95,
                    'temperature': 0.7
                }
            }
            
            # Use different models based on whether it's a top MNC
            model = 'facebook/roberta-base' if is_top_mnc else 'distilbert-base-uncased'
            
            response = requests.post(
                f'https://api-inference.huggingface.co/models/{model}',
                headers=headers,
                json=data
            )
            
            if response.status_code == 200:
                result = response.json()
                if isinstance(result, list) and len(result) > 0:
                    # Enhanced analysis for top MNCs
                    if is_top_mnc:
                        for item in result:
                            if isinstance(item, dict):
                                score = item.get('score', 0)
                                if score > 0.8:  # High confidence in vulnerability
                                    vulnerabilities.append({
                                        'type': 'AI Analysis',
                                        'severity': 'Critical',
                                        'description': 'Potential zero-day vulnerability detected by AI analysis',
                                        'recommendation': 'Immediate review and patching required',
                                        'confidence_score': score
                                    })
                    else:
                        score = result[0].get('score', 0)
                        if score > 0.8:
                            vulnerabilities.append({
                                'type': 'AI Analysis',
                                'severity': 'Medium',
                                'description': 'Potential security issue detected by AI analysis',
                                'recommendation': 'Review the content for potential security issues',
                                'confidence_score': score
                            })

        except Exception as e:
            print(f"Error analyzing with Hugging Face: {str(e)}")

        return vulnerabilities

    def _start_continuous_recording(self, url: str):
        """Start continuous recording for vulnerability detection"""
        if self.auto_record and not self.recording:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"vulnerability_scan_{timestamp}.mp4"
            self.screen_recorder.start(output_file)
            self.recording = True
            self.current_recording = {
                'file': output_file,
                'start_time': timestamp,
                'vulnerabilities': []
            }
            print(f"Continuous recording started: {output_file}")

    def _stop_continuous_recording(self):
        """Stop continuous recording"""
        if self.recording:
            self.screen_recorder.stop()
            self.recording = False
            if self.current_recording:
                self.current_recording['end_time'] = datetime.now().strftime("%Y%m%d_%H%M%S")
            print("Continuous recording stopped")

    def _update_recording_metadata(self, vulnerabilities: List[Dict[str, str]], is_zero_day: bool = False, is_ai: bool = False):
        """Update recording metadata with new vulnerabilities"""
        if self.current_recording:
            for vuln in vulnerabilities:
                vuln_info = {
                    'type': vuln['type'],
                    'severity': vuln['severity'],
                    'timestamp': datetime.now().strftime("%Y%m%d_%H%M%S"),
                    'is_zero_day': is_zero_day,
                    'is_ai': is_ai
                }
                self.current_recording['vulnerabilities'].append(vuln_info)
                print(f"Vulnerability detected during recording: {vuln['type']} ({vuln['severity']})")

    def start_manual_hunting(self, target_url: str):
        """Start manual hunting mode with screen recording"""
        print("\nStarting Manual Hunting Mode...")
        print("Press 'r' to start/stop recording")
        print("Press 's' to save screenshot")
        print("Press 'q' to quit manual hunting")
        
        self.recording = False
        self.screen_recorder = ScreenRecorder()
        
        def keyboard_listener():
            while True:
                if keyboard.is_pressed('r'):
                    if not self.recording:
                        self.start_recording()
                    else:
                        self.stop_recording()
                    time.sleep(0.5)  # Prevent multiple triggers
                elif keyboard.is_pressed('s'):
                    self.take_screenshot()
                    time.sleep(0.5)
                elif keyboard.is_pressed('q'):
                    if self.recording:
                        self.stop_recording()
                    break
                time.sleep(0.1)
        
        keyboard_thread = threading.Thread(target=keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()
        
        try:
            while True:
                if keyboard.is_pressed('q'):
                    break
                time.sleep(0.1)
        except KeyboardInterrupt:
            pass
        finally:
            if self.recording:
                self.stop_recording()

    def start_recording(self):
        """Start screen recording"""
        if not self.recording:
            self.recording = True
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"manual_hunt_{timestamp}.mp4"
            self.screen_recorder.start(output_file)
            print(f"Recording started: {output_file}")

    def stop_recording(self):
        """Stop screen recording"""
        if self.recording:
            self.recording = False
            self.screen_recorder.stop()
            print("Recording stopped")

    def take_screenshot(self):
        """Take a screenshot of the current screen"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        screenshot_file = f"screenshot_{timestamp}.png"
        pyautogui.screenshot(screenshot_file)
        print(f"Screenshot saved: {screenshot_file}")

    def _automate_burp_suite(self):
        """Automate Burp Suite operations"""
        try:
            # Start Burp Suite from specific location
            burp_path = r"C:\Users\vellu\burp - 25 pro\BurpLoaderKeygen117.jar"
            if not os.path.exists(burp_path):
                print(f"Error: Burp Suite not found at {burp_path}")
                return False

            # Start Java with Burp Suite
            subprocess.Popen(['java', '-jar', burp_path])
            time.sleep(10)  # Wait longer for Burp to start
            
            # Get Burp window
            self.burp_app = Application().connect(title_re=".*Burp Suite.*", timeout=30)
            burp_window = self.burp_app.window(title_re=".*Burp Suite.*")
            
            # Configure proxy
            burp_window.menu_select("Proxy -> Options")
            time.sleep(2)
            
            # Enable interception
            burp_window.menu_select("Proxy -> Intercept -> Intercept is on")
            
            print("Burp Suite automated and ready for testing")
            return True
        except Exception as e:
            print(f"Error automating Burp Suite: {str(e)}")
            return False

    def _automate_browser(self, url: str):
        """Automate browser operations"""
        try:
            # Start Chrome with proxy settings
            options = webdriver.ChromeOptions()
            options.add_argument('--proxy-server=127.0.0.1:8080')
            options.add_argument('--ignore-certificate-errors')  # Ignore SSL errors
            options.add_argument('--disable-web-security')  # Disable same-origin policy
            self.browser = webdriver.Chrome(options=options)
            
            # Navigate to target URL
            self.browser.get(url)
            time.sleep(2)
            
            # Find and click all links
            links = self.browser.find_elements(By.TAG_NAME, "a")
            for link in links:
                try:
                    href = link.get_attribute('href')
                    if href and urlparse(href).netloc == urlparse(url).netloc:
                        link.click()
                        time.sleep(1)
                except:
                    continue
            
            # Find and submit all forms
            forms = self.browser.find_elements(By.TAG_NAME, "form")
            for form in forms:
                try:
                    # Find all input fields
                    inputs = form.find_elements(By.TAG_NAME, "input")
                    for input_field in inputs:
                        # Fill input fields with test data
                        input_type = input_field.get_attribute("type")
                        if input_type == "text":
                            input_field.send_keys("test' OR '1'='1")
                        elif input_type == "password":
                            input_field.send_keys("password123")
                        elif input_type == "email":
                            input_field.send_keys("test@example.com")
                    
                    # Submit form
                    form.submit()
                    time.sleep(1)
                except:
                    continue
            
            print("Browser automation completed")
            return True
        except Exception as e:
            print(f"Error automating browser: {str(e)}")
            return False

    def _automate_nmap(self, url: str):
        """Automate Nmap scanning"""
        try:
            host = urlparse(url).netloc
            nm = nmap.PortScanner()
            
            # Run comprehensive scan
            nm.scan(host, arguments='-sV -sC -p- -A -T4')
            
            # Process results
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        if service['state'] == 'open':
                            print(f"Open port {port} running {service['name']} {service['version']}")
            
            return True
        except Exception as e:
            print(f"Error running Nmap scan: {str(e)}")
            return False

    def _automate_security_testing(self, url: str):
        """Automate complete security testing process"""
        try:
            # Start recording
            self._start_continuous_recording(url)
            
            # Start Burp Suite
            if not self._automate_burp_suite():
                print("Failed to start Burp Suite. Please ensure it's installed at the specified location.")
                return
            
            # Start browser automation
            if not self._automate_browser(url):
                print("Failed to automate browser. Please check Chrome installation and WebDriver.")
                return
            
            # Run Nmap scan
            if not self._automate_nmap(url):
                print("Failed to run Nmap scan. Please ensure Nmap is installed.")
                return
            
            # Monitor Burp Suite for findings
            while True:
                try:
                    # Check for vulnerabilities in intercepted requests
                    burp_window = self.burp_app.window(title_re=".*Burp Suite.*")
                    if burp_window.exists():
                        # Forward intercepted requests
                        burp_window.menu_select("Proxy -> Intercept -> Forward")
                        time.sleep(0.5)
                except:
                    break
            
            # Stop recording
            self._stop_continuous_recording()
            
            print("Automated security testing completed")
            return True
        except Exception as e:
            print(f"Error in automated security testing: {str(e)}")
            return False

    def start_automated_hunting(self, target_url: str):
        """Start automated hunting mode"""
        print("\nStarting Automated Hunting Mode...")
        print("This will automatically:")
        print("1. Start Burp Suite")
        print("2. Configure proxy settings")
        print("3. Launch browser with proxy")
        print("4. Automatically test all forms and links")
        print("5. Run Nmap scans")
        print("6. Record all activities")
        
        input("Press Enter to start automated hunting...")
        
class ScreenRecorder:
    def __init__(self):
        self.recording = False
        self.fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        self.out = None
        self.screen_size = pyautogui.size()

    def start(self, output_file):
        """Start recording"""
        self.recording = True
        self.out = cv2.VideoWriter(output_file, self.fourcc, 20.0, self.screen_size)
        self.record_thread = threading.Thread(target=self._record)
        self.record_thread.start()

    def stop(self):
        """Stop recording"""
        self.recording = False
        if self.record_thread:
            self.record_thread.join()
        if self.out:
            self.out.release()

    def _record(self):
        """Record screen"""
        while self.recording:
            img = pyautogui.screenshot()
            frame = np.array(img)
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            self.out.write(frame)
            time.sleep(0.05)  # 20 FPS

def main():
    """Main function to run the scanner"""
    scanner = VulnerabilityScanner()
    print("Vulnerability Scanner with Manual Hunting Mode")
    print("1. Automated Scan")
    print("2. Manual Hunting Mode")
    choice = input("Select mode (1/2): ")
    
    if choice == "1":
        url = input("Enter the website URL to scan: ")
        results = scanner.scan(url)
        print("\nScan Results:")
        print(json.dumps(results, indent=2))
    elif choice == "2":
        url = input("Enter the website URL for manual hunting: ")
        scanner.start_manual_hunting(url)
    else:
        print("Invalid choice")

if __name__ == "__main__":
    main() 